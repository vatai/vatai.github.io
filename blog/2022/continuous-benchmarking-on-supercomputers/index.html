<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>A paper <a href="https://doi.org/10.1145/3324989.3325719" rel="external nofollow noopener" target="_blank">Towards Continuous Benchmarking: An Automated Performance Evaluation Framework for High Performance Software</a> by Anzt, H. et al. describes the posibilities of <em>continuous benchmarking</em> (CB), however it doesn’t give direct instructions how to implement it. Looking at the source code is always a possibility, but the <code class="language-plaintext highlighter-rouge">yaml</code> files there aren’t really documented (which is no surprises since they are pretty self documenting). Still, I hope this post will help people who unfamiliar with <em>Continuous X</em> approaches (where X can be integration, development, benchmarking etc).</p> <h1 id="overview">Overview</h1> <p>We will need 3 things:</p> <ul> <li>The <strong>app/benchmark</strong> itself, which we will assume to be given.</li> <li>We need to set up a <strong>“self-hosted runner”</strong>, the program running on the supercomputer, which will be executing the actions such as compiling the app and submitting job to the scheduler of the supercomputer.</li> <li>The <strong>yaml file</strong> which describes when and what should be executed by the “runner”.</li> </ul> <p>I’ll be describing the scenario for GitHub. Other sites like GitLab have similar systems.</p> <h2 id="self-hosted-runner">Self-hosted runner</h2> <p>In the Github repo <strong>settings</strong>, on the left-hand side, under <strong>Actions</strong> there is a <strong>Runners</strong> page. In the top-right corner there is a green <strong>New self-hosted runner</strong> button. Clicking on this button brings up a page where you can select the OS and architecture. For supercomputers Linux, x64 is a good choice since usually that is something that will run on the login node.</p> <p>Below the OS and architecture choice, the page lists the commands needed to install the self-hosted runner. This consists of several sections.</p> <p>The first section described how to download, validate and extract the runner software. <strong>Don’t use these instructions</strong>, use the ones from the GitHub settings page.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create a folder
$ mkdir actions-runner &amp;&amp; cd actions-runner
# Download the latest runner package
$ curl -o actions-runner-linux-x64-2.291.1.tar.gz -L https://github.com/actions/runner/releases/download/v2.291.1/actions-runner-linux-x64-2.291.1.tar.gz
# Optional: Validate the hash
$ echo "1bde3f2baf514adda5f8cf2ce531edd2f6be52ed84b9b6733bf43006d36dcd4c  actions-runner-linux-x64-2.291.1.tar.gz" | shasum -a 256 -c
# Extract the installer
$ tar xzf ./actions-runner-linux-x64-2.291.1.tar.gz
</code></pre></div></div> <p>The second section describes how to configure and run the self-hosted runner. Again <strong>don’t use these instructions</strong>, use the ones provided on the settings page, since the <code class="language-plaintext highlighter-rouge">--url</code> and the <code class="language-plaintext highlighter-rouge">--token</code> are dependent on the repo you want to add the runner to. The <code class="language-plaintext highlighter-rouge">./config.sh</code> asks a few questions, but generally it is very simple and usually the default answers are acceptable. The last command <code class="language-plaintext highlighter-rouge">./run.sh</code> is the runner itself, it connects to GitHub, and needs to be running to be able to accept workflows/jobs. See <a href="#security">note</a> about security.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create the runner and start the configuration experience
$ ./config.sh --url https://github.com/&lt;user&gt;/&lt;repo&gt; --token &lt;token&gt;
# Last step, run it!
$ ./run.sh
</code></pre></div></div> <p>The third section describes how to enable the runner in the Yaml file which is described in the next section.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Use this YAML in your workflow file for each job
runs-on: self-hosted
</code></pre></div></div> <p>This is the procedure to add a self-hosted runner to a repo. To the best of my knowledge, self-hosted runners can be added to GitHub users or GitHub organisations.</p> <h2 id="yaml-workflow-file">Yaml workflow file</h2> <p>To automatically run commands, we need to create a <code class="language-plaintext highlighter-rouge">&lt;name&gt;.yml</code> file in the <code class="language-plaintext highlighter-rouge">&lt;repo&gt;/.github/workflows/</code> directory, for example with the following contents:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># .github/workflows/build-and-submit.yml
name: Build and submit
on: push
jobs:
  build:
    name: Build
    runs-on: [self-hosted,login-node]
    steps:
    - uses: actions/checkout@master
    - name: Create build dir
      run: mkdir build
    - name: Run cmake
      working-directory: ./build
      run: CXX=FCCpx cmake ..
    - name: Build
      run: cmake --build build --clean-first
    - name: Submit
      run: pjsub -g $(stat . -c %G) sub.sh
</code></pre></div></div> <p>Each <code class="language-plaintext highlighter-rouge">&lt;name&gt;.yml</code> file (which can have any name) describes a workflow, with its <code class="language-plaintext highlighter-rouge">name:</code> (which can be any string), and the event when it will be executed. The example above will be exectuted <code class="language-plaintext highlighter-rouge">on: push</code>.</p> <p>Each workflow consists of one or more <code class="language-plaintext highlighter-rouge">jobs:</code>. Multiple jobs are, by default, executed in parallel. In the example, for simplicity, there is only one job, with the custom identifier <code class="language-plaintext highlighter-rouge">build:</code> (this can be a different identifier e.g. <code class="language-plaintext highlighter-rouge">job1:</code>). Each job has a <code class="language-plaintext highlighter-rouge">name:</code> (similarly to a workflow), and each job needs to specify where it is should run using the <code class="language-plaintext highlighter-rouge">runs-on:</code> value. Without self-hosted runners, we can specify here a docker image (something like <code class="language-plaintext highlighter-rouge">ubuntu-20.04</code>), but in our case <code class="language-plaintext highlighter-rouge">[self-hosted,login-node]</code> specifies that the job should be executed on a <code class="language-plaintext highlighter-rouge">self-hosted</code> runner. The <code class="language-plaintext highlighter-rouge">login-node</code> is custom label which can be added to the runner on GitHub.</p> <p>The main part of a job is the <code class="language-plaintext highlighter-rouge">steps:</code> field, which describes a list of steps which are executed sequentially. The job in the example has 5 steps. The first step is an “external” step (like importing a library), which checks out the master branch of the repository. The second, third and fourth steps create a <code class="language-plaintext highlighter-rouge">build</code> directory, call <code class="language-plaintext highlighter-rouge">cmake</code> in that directory (using the <code class="language-plaintext highlighter-rouge">working-directory:</code>), and builds the app using <code class="language-plaintext highlighter-rouge">cmake --build</code>. Finally, the last step, calls the command of the supercomputer scheduler to submit the <code class="language-plaintext highlighter-rouge">sub.sh</code> script.</p> <h1 id="observing-the-actions">Observing the actions</h1> <p>The top bar of a GitHub repository has an “Actions” page.</p> <p><img src="/assets/images/actions.png" alt="Actions button" title="Actions button"></p> <p>This page lists the workflows which were executed for the given repository. Clicking on a workflow, brings up a list of jobs defined for that workflow, and clicking on a job brings up the steps of that job. Clicking on a step expands it and displays the</p> <p><img src="/assets/images/observing.png" alt="Observing actions" title="Observing actions"></p> <h1 id="security">Security</h1> <p>This is obviously a security issue. The runner script <code class="language-plaintext highlighter-rouge">./run.sh</code> should be running all the time, connected to GitHub.com, waiting for jobs. As stated on GitHub, this should be enabled only for <strong>private</strong> repositories.</p> <h1 id="future-work">Future work</h1> <p>Next, I’d like to figure out how to write a workflow or a job which monitors when the submitted script finishes.</p> </body></html>